{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "realtime-transcriber-01",
  "type": "registry:block",
  "description": "Scribe V2 Realtime Transcriber",
  "dependencies": [
    "@elevenlabs/react",
    "framer-motion"
  ],
  "registryDependencies": [
    "badge",
    "button",
    "scroll-area",
    "https://ui.elevenlabs.io/r/shimmering-text.json"
  ],
  "files": [
    {
      "path": "blocks/realtime-transcriber-01/page.tsx",
      "content": "\"use client\"\n\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from \"react\"\nimport Link from \"next/link\"\nimport { useScribe } from \"@elevenlabs/react\"\nimport { AnimatePresence, motion } from \"framer-motion\"\nimport { Copy } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { useDebounce } from \"@/registry/elevenlabs-ui/hooks/use-debounce\"\nimport { usePrevious } from \"@/registry/elevenlabs-ui/hooks/use-previous\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { Button } from \"@/components/ui/button\"\nimport { ShimmeringText } from \"@/components/ui/shimmering-text\"\n\nimport { getScribeToken } from \"./actions/get-scribe-token\"\nimport { LanguageSelector } from \"./components/language-selector\"\n\ninterface RecordingState {\n  error: string\n  latenciesMs: number[]\n}\n\nconst TranscriptCharacter = React.memo(\n  ({ char, delay }: { char: string; delay: number }) => {\n    return (\n      <motion.span\n        initial={{ filter: `blur(3.5px)`, opacity: 0 }}\n        animate={{ filter: `none`, opacity: 1 }}\n        transition={{ duration: 0.5, delay }}\n        style={{ willChange: delay > 0 ? \"filter, opacity\" : \"auto\" }}\n      >\n        {char}\n      </motion.span>\n    )\n  }\n)\nTranscriptCharacter.displayName = \"TranscriptCharacter\"\n\n// Memoize background effects to prevent re-renders\nconst BackgroundAura = React.memo(\n  ({ status, isConnected }: { status: string; isConnected: boolean }) => {\n    return (\n      <div\n        className={cn(\n          \"pointer-events-none fixed inset-0 opacity-0 transition-opacity duration-700 ease-out\",\n          status === \"connecting\" && \"opacity-40 duration-500 ease-in\",\n          isConnected && \"opacity-100 duration-700 ease-in\"\n        )}\n      >\n        {/* Center bottom pool - main glow */}\n        <div\n          className=\"absolute bottom-0 left-1/2 -translate-x-1/2\"\n          style={{\n            width: \"130%\",\n            height: \"20vh\",\n            background:\n              \"radial-gradient(ellipse 100% 100% at 50% 100%, rgba(34, 211, 238, 0.5) 0%, rgba(168, 85, 247, 0.4) 35%, rgba(251, 146, 60, 0.5) 70%, transparent 100%)\",\n            filter: \"blur(80px)\",\n          }}\n        />\n\n        {/* Pulsing layer */}\n        <div\n          className=\"absolute bottom-0 left-1/2 -translate-x-1/2 animate-pulse\"\n          style={{\n            width: \"100%\",\n            height: \"18vh\",\n            background:\n              \"radial-gradient(ellipse 100% 100% at 50% 100%, rgba(134, 239, 172, 0.5) 0%, rgba(192, 132, 252, 0.4) 50%, transparent 100%)\",\n            filter: \"blur(60px)\",\n            animationDuration: \"4s\",\n          }}\n        />\n\n        {/* Left corner bloom */}\n        <div\n          className=\"absolute bottom-0 left-0\"\n          style={{\n            width: \"25vw\",\n            height: \"30vh\",\n            background:\n              \"radial-gradient(circle at 0% 100%, rgba(34, 211, 238, 0.5) 0%, rgba(134, 239, 172, 0.3) 30%, transparent 60%)\",\n            filter: \"blur(70px)\",\n          }}\n        />\n\n        {/* Left rising glow - organic curve */}\n        <div\n          className=\"absolute bottom-0 -left-8\"\n          style={{\n            width: \"20vw\",\n            height: \"45vh\",\n            background:\n              \"radial-gradient(ellipse 50% 100% at 10% 100%, rgba(34, 211, 238, 0.4) 0%, rgba(134, 239, 172, 0.25) 25%, transparent 60%)\",\n            filter: \"blur(60px)\",\n            animation: \"pulseGlow 5s ease-in-out infinite alternate\",\n          }}\n        />\n\n        {/* Right corner bloom */}\n        <div\n          className=\"absolute right-0 bottom-0\"\n          style={{\n            width: \"25vw\",\n            height: \"30vh\",\n            background:\n              \"radial-gradient(circle at 100% 100%, rgba(251, 146, 60, 0.5) 0%, rgba(251, 146, 60, 0.3) 30%, transparent 60%)\",\n            filter: \"blur(70px)\",\n          }}\n        />\n\n        {/* Right rising glow - organic curve */}\n        <div\n          className=\"absolute -right-8 bottom-0\"\n          style={{\n            width: \"20vw\",\n            height: \"45vh\",\n            background:\n              \"radial-gradient(ellipse 50% 100% at 90% 100%, rgba(251, 146, 60, 0.4) 0%, rgba(192, 132, 252, 0.25) 25%, transparent 60%)\",\n            filter: \"blur(60px)\",\n            animation: \"pulseGlow 5s ease-in-out infinite alternate-reverse\",\n          }}\n        />\n\n        {/* Shimmer overlay */}\n        <div\n          className=\"absolute bottom-0 left-1/2 -translate-x-1/2\"\n          style={{\n            width: \"100%\",\n            height: \"15vh\",\n            background:\n              \"linear-gradient(90deg, rgba(34, 211, 238, 0.3) 0%, rgba(168, 85, 247, 0.3) 30%, rgba(251, 146, 60, 0.3) 60%, rgba(134, 239, 172, 0.3) 100%)\",\n            filter: \"blur(30px)\",\n            animation: \"shimmer 8s linear infinite\",\n          }}\n        />\n      </div>\n    )\n  }\n)\nBackgroundAura.displayName = \"BackgroundAura\"\n\n// Memoize bottom controls with comparison function\nconst BottomControls = React.memo(\n  ({\n    isConnected,\n    hasError,\n    isMac,\n    onStop,\n  }: {\n    isConnected: boolean\n    hasError: boolean\n    isMac: boolean\n    onStop: () => void\n  }) => {\n    return (\n      <AnimatePresence mode=\"popLayout\">\n        {isConnected && !hasError && (\n          <motion.div\n            key=\"bottom-controls\"\n            initial={{ opacity: 0, y: 20 }}\n            animate={{\n              opacity: 1,\n              y: 0,\n              transition: { duration: 0.25, delay: 0.2 },\n            }}\n            exit={{\n              opacity: 0,\n              y: 20,\n              transition: { duration: 0.35 },\n            }}\n            className=\"fixed bottom-8 left-1/2 z-50 flex -translate-x-1/2 items-center gap-2\"\n          >\n            {/* Stop button - always present */}\n            <button\n              onClick={onStop}\n              className=\"bg-foreground text-background border-foreground/10 inline-flex items-center gap-2 rounded-lg border px-3 py-2 text-sm font-medium shadow-lg transition-opacity hover:opacity-90\"\n            >\n              Stop\n              <kbd className=\"border-background/20 bg-background/10 inline-flex h-5 items-center rounded border px-1.5 font-mono text-xs\">\n                {isMac ? \"⌘K\" : \"Ctrl+K\"}\n              </kbd>\n            </button>\n          </motion.div>\n        )}\n      </AnimatePresence>\n    )\n  },\n  (prev, next) => {\n    // Return true to SKIP re-render (props are equal)\n    // Return false to re-render (props changed)\n    if (prev.isConnected !== next.isConnected) return false\n    if (prev.hasError !== next.hasError) return false\n    if (prev.isMac !== next.isMac) return false\n    return true\n  }\n)\nBottomControls.displayName = \"BottomControls\"\n\nexport default function RealtimeTranscriber01() {\n  const [recording, setRecording] = useState<RecordingState>({\n    error: \"\",\n    latenciesMs: [],\n  })\n  const [selectedLanguage, setSelectedLanguage] = useState<string | null>(null)\n  const [isOperating, setIsOperating] = useState(false)\n\n  // Detect platform for keyboard shortcut display\n  const [isMac, setIsMac] = useState(true)\n  useEffect(() => {\n    setIsMac(/(Mac|iPhone|iPod|iPad)/i.test(navigator.userAgent))\n  }, [])\n\n  const segmentStartMsRef = useRef<number | null>(null)\n  const lastTranscriptRef = useRef<string>(\"\")\n\n  // Audio refs for sound effects\n  const startSoundRef = useRef<HTMLAudioElement | null>(null)\n  const endSoundRef = useRef<HTMLAudioElement | null>(null)\n  const errorSoundRef = useRef<HTMLAudioElement | null>(null)\n\n  // Guards to prevent race conditions\n  const shouldBeConnectedRef = useRef(false) // Tracks desired connection state\n  const errorTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Memoize callbacks to prevent useScribe from re-running\n  const onPartialTranscript = useCallback((data: { text?: string }) => {\n    const currentText = data.text || \"\"\n\n    // Skip if text hasn't changed (prevents re-renders on duplicate events)\n    if (currentText === lastTranscriptRef.current) {\n      return\n    }\n\n    lastTranscriptRef.current = currentText\n\n    // Record latency if we have a start time - mimics xi's recordLatency\n    if (currentText.length > 0 && segmentStartMsRef.current != null) {\n      const latency = performance.now() - segmentStartMsRef.current\n      console.log(\"[Scribe] Partial latency:\", latency, \"ms\")\n      setRecording((prev) => ({\n        ...prev,\n        latenciesMs: [...prev.latenciesMs.slice(-29), latency],\n      }))\n      // Reset to null like xi does - next audio will set it again\n      segmentStartMsRef.current = null\n    }\n  }, [])\n\n  const onFinalTranscript = useCallback((data: { text?: string }) => {\n    // Reset last transcript on final\n    lastTranscriptRef.current = \"\"\n\n    // Record latency if we have a start time - mimics xi's recordLatency\n    if (\n      data.text &&\n      data.text.length > 0 &&\n      segmentStartMsRef.current != null\n    ) {\n      const latency = performance.now() - segmentStartMsRef.current\n      console.log(\"[Scribe] Final latency:\", latency, \"ms\")\n      setRecording((prev) => ({\n        ...prev,\n        latenciesMs: [...prev.latenciesMs.slice(-29), latency],\n      }))\n    }\n    // Reset to null like xi does\n    segmentStartMsRef.current = null\n  }, [])\n\n  const onError = useCallback((error: Error | Event) => {\n    console.error(\"[Scribe] Error:\", error)\n    const errorMessage =\n      error instanceof Error ? error.message : \"Transcription error\"\n\n    // Clear any existing error timeout\n    if (errorTimeoutRef.current) {\n      clearTimeout(errorTimeoutRef.current)\n    }\n\n    // Only show errors that persist for more than 500ms (debounce transient errors)\n    errorTimeoutRef.current = setTimeout(() => {\n      setRecording((prev) => ({\n        ...prev,\n        error: errorMessage,\n      }))\n      // Play error sound\n      errorSoundRef.current?.play().catch(() => {})\n    }, 500)\n  }, [])\n\n  // Memoize the configuration object to prevent useScribe from re-initializing\n  const scribeConfig = useMemo(\n    () => ({\n      modelId: \"scribe_realtime_v2\" as const,\n      onPartialTranscript,\n      onFinalTranscript,\n      onError,\n    }),\n    [onPartialTranscript, onFinalTranscript, onError]\n  )\n\n  const scribe = useScribe(scribeConfig)\n\n  // Simulate audio chunk timing - set timer when likely sending audio\n  useEffect(() => {\n    if (!scribe.isConnected) return\n\n    // While connected, continuously set timer to simulate audio chunks being sent\n    // This approximates xi's sendAudioChunk behavior\n    const interval = setInterval(() => {\n      // Only set if null (like xi does: if (this.segmentStartMs == null))\n      if (segmentStartMsRef.current === null) {\n        segmentStartMsRef.current = performance.now()\n        console.log(\"[Scribe] Timer set (simulating audio chunk)\")\n      }\n    }, 100) // Check every 100ms (audio chunks are typically sent frequently)\n\n    return () => clearInterval(interval)\n  }, [scribe.isConnected])\n\n  const handleToggleRecording = useCallback(async () => {\n    // Handle disconnect request\n    if (scribe.isConnected || scribe.status === \"connecting\") {\n      console.log(\"[Scribe] Disconnect requested\")\n      shouldBeConnectedRef.current = false\n      setIsOperating(true) // Prevent re-entry during disconnect\n\n      // Clear any pending error timeouts\n      if (errorTimeoutRef.current) {\n        clearTimeout(errorTimeoutRef.current)\n        errorTimeoutRef.current = null\n      }\n\n      // Disconnect immediately\n      console.log(\"[Scribe] Disconnecting...\")\n      scribe.disconnect()\n      scribe.clearTranscripts()\n      segmentStartMsRef.current = null\n      setRecording((prev) => ({ ...prev, latenciesMs: [], error: \"\" }))\n\n      // Play end sound (reset first for reliability)\n      if (endSoundRef.current) {\n        endSoundRef.current.currentTime = 0\n        endSoundRef.current.play().catch(() => {})\n      }\n\n      // Reset operating flag after a short delay\n      setTimeout(() => {\n        setIsOperating(false)\n      }, 300)\n      return\n    }\n\n    // Prevent multiple simultaneous connect operations\n    if (isOperating) {\n      console.log(\"[Scribe] Operation already in progress, ignoring\")\n      return\n    }\n\n    shouldBeConnectedRef.current = true\n    setIsOperating(true)\n\n    try {\n      console.log(\"[Scribe] Fetching token...\")\n\n      // Clear any pending error timeouts\n      if (errorTimeoutRef.current) {\n        clearTimeout(errorTimeoutRef.current)\n        errorTimeoutRef.current = null\n      }\n      setRecording((prev) => ({ ...prev, error: \"\", latenciesMs: [] }))\n      segmentStartMsRef.current = null\n\n      const result = await getScribeToken()\n\n      // Check if user still wants to connect after token fetch\n      if (!shouldBeConnectedRef.current) {\n        console.log(\"[Scribe] User cancelled during token fetch\")\n        return\n      }\n\n      if (result.error || !result.token) {\n        throw new Error(result.error || \"Failed to get token\")\n      }\n\n      console.log(\"[Scribe] Connecting...\")\n      await scribe.connect({\n        token: result.token,\n        languageCode: selectedLanguage || undefined,\n        microphone: {\n          echoCancellation: false,\n          noiseSuppression: false,\n          autoGainControl: true,\n        },\n      })\n\n      console.log(\"[Scribe] Connected successfully\")\n\n      // Check if user still wants to be connected\n      if (!shouldBeConnectedRef.current) {\n        console.log(\n          \"[Scribe] User cancelled during connection, disconnecting...\"\n        )\n        scribe.disconnect()\n        scribe.clearTranscripts()\n        segmentStartMsRef.current = null\n        setRecording((prev) => ({ ...prev, latenciesMs: [], error: \"\" }))\n        if (endSoundRef.current) {\n          endSoundRef.current.currentTime = 0\n          endSoundRef.current.play().catch(() => {})\n        }\n        return\n      }\n\n      // Play start sound with a small delay for reliability\n      setTimeout(() => {\n        if (\n          shouldBeConnectedRef.current &&\n          scribe.isConnected &&\n          startSoundRef.current\n        ) {\n          console.log(\"[Scribe] Playing start sound\")\n          startSoundRef.current.currentTime = 0\n          startSoundRef.current\n            .play()\n            .then(() => console.log(\"[Scribe] Start sound played\"))\n            .catch((err) => console.error(\"[Scribe] Start sound failed:\", err))\n        } else {\n          console.log(\"[Scribe] Start sound conditions not met:\", {\n            shouldBeConnected: shouldBeConnectedRef.current,\n            isConnected: scribe.isConnected,\n            hasAudio: !!startSoundRef.current,\n          })\n        }\n      }, 50)\n    } catch (error) {\n      console.error(\"[Scribe] Connection error:\", error)\n      shouldBeConnectedRef.current = false\n      setRecording((prev) => ({\n        ...prev,\n        error:\n          error instanceof Error ? error.message : \"Failed to start recording\",\n      }))\n    } finally {\n      setIsOperating(false)\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    isOperating,\n    scribe.connect,\n    scribe.disconnect,\n    scribe.clearTranscripts,\n    scribe.isConnected,\n    scribe.status,\n    selectedLanguage,\n  ])\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Cmd+K (Mac) or Ctrl+K (Windows/Linux) to toggle recording\n      if (\n        e.key === \"k\" &&\n        (e.metaKey || e.ctrlKey) &&\n        e.target instanceof HTMLElement &&\n        ![\"INPUT\", \"TEXTAREA\"].includes(e.target.tagName)\n      ) {\n        e.preventDefault()\n        handleToggleRecording()\n      }\n    }\n\n    window.addEventListener(\"keydown\", handleKeyDown)\n    return () => {\n      window.removeEventListener(\"keydown\", handleKeyDown)\n    }\n  }, [handleToggleRecording])\n\n  // Preload audio files on mount\n  useEffect(() => {\n    const sounds = [\n      {\n        ref: startSoundRef,\n        url: \"https://ui.elevenlabs.io/sounds/transcriber-start.mp3\",\n      },\n      {\n        ref: endSoundRef,\n        url: \"https://ui.elevenlabs.io/sounds/transcriber-end.mp3\",\n      },\n      {\n        ref: errorSoundRef,\n        url: \"https://ui.elevenlabs.io/sounds/transcriber-error.mp3\",\n      },\n    ]\n\n    // Preload all sounds and ensure they're ready to play\n    sounds.forEach(({ ref, url }) => {\n      const audio = new Audio(url)\n      audio.volume = 0.6\n      audio.preload = \"auto\"\n\n      // Force load the audio\n      audio.load()\n\n      // Play silently once to \"unlock\" audio playback (browser requirement)\n      const unlockAudio = () => {\n        audio\n          .play()\n          .then(() => {\n            audio.pause()\n            audio.currentTime = 0\n          })\n          .catch(() => {\n            // Autoplay blocked, will work after user interaction\n          })\n      }\n\n      // Try to unlock audio on first interaction\n      if (audio.readyState >= 2) {\n        unlockAudio()\n      } else {\n        audio.addEventListener(\"canplaythrough\", unlockAudio, { once: true })\n      }\n\n      ref.current = audio\n    })\n  }, [])\n\n  const fullTranscript = useMemo(\n    () =>\n      scribe.finalTranscripts.map((t: { text: string }) => t.text).join(\" \"),\n    [scribe.finalTranscripts]\n  )\n\n  // Create a stable displayText that only changes when actual text changes\n  const displayText = useMemo(() => {\n    const text = recording.error || scribe.partialTranscript || fullTranscript\n    return text\n  }, [recording.error, scribe.partialTranscript, fullTranscript])\n\n  // Use a ref for previous displayText to avoid unnecessary re-renders\n  const prevDisplayTextRef = useRef(displayText)\n  const stableDisplayText = useMemo(() => {\n    if (displayText !== prevDisplayTextRef.current) {\n      prevDisplayTextRef.current = displayText\n    }\n    return prevDisplayTextRef.current\n  }, [displayText])\n\n  const hasContent = Boolean(stableDisplayText)\n\n  return (\n    <div className=\"relative mx-auto flex h-full w-full max-w-4xl flex-col items-center justify-center\">\n      {/* Bottom aura effect - Multi-layered prismatic glow */}\n      <BackgroundAura status={scribe.status} isConnected={scribe.isConnected} />\n\n      <style jsx>{`\n        @keyframes shimmer {\n          0% {\n            transform: translateX(-20%) scale(1);\n          }\n          50% {\n            transform: translateX(20%) scale(1.1);\n          }\n          100% {\n            transform: translateX(-20%) scale(1);\n          }\n        }\n        @keyframes drift {\n          0% {\n            transform: translateX(-10%) scale(1);\n          }\n          100% {\n            transform: translateX(10%) scale(1.05);\n          }\n        }\n        @keyframes pulseGlow {\n          0% {\n            opacity: 0.5;\n            transform: translateY(0) scale(1);\n          }\n          100% {\n            opacity: 0.8;\n            transform: translateY(-5%) scale(1.02);\n          }\n        }\n      `}</style>\n\n      <div className=\"relative flex h-full w-full flex-col items-center justify-center gap-8 overflow-hidden px-8 py-12\">\n        {/* Main transcript area */}\n        <div className=\"relative flex min-h-[350px] w-full flex-1 items-center justify-center overflow-hidden\">\n          {hasContent && (\n            <TranscriberTranscript\n              transcript={stableDisplayText}\n              error={recording.error}\n              isPartial={Boolean(scribe.partialTranscript)}\n              isConnected={scribe.isConnected}\n            />\n          )}\n\n          {!hasContent && (\n            <div className=\"flex max-h-full w-full max-w-sm flex-col items-center gap-8 overflow-y-auto\">\n              {/* Status text - transitions smoothly between states */}\n              <div className=\"relative flex min-h-[48px] w-full items-center justify-center\">\n                <div\n                  className={cn(\n                    \"absolute inset-0 flex items-center justify-center transition-opacity duration-500\",\n                    scribe.status === \"connecting\"\n                      ? \"opacity-100\"\n                      : \"pointer-events-none opacity-0\"\n                  )}\n                >\n                  <ShimmeringText\n                    text=\"Connecting...\"\n                    className=\"text-2xl font-light tracking-wide whitespace-nowrap\"\n                  />\n                </div>\n                <div\n                  className={cn(\n                    \"absolute inset-0 flex items-center justify-center transition-opacity duration-500\",\n                    scribe.isConnected\n                      ? \"opacity-100\"\n                      : \"pointer-events-none opacity-0\"\n                  )}\n                >\n                  <ShimmeringText\n                    text=\"Say something aloud...\"\n                    className=\"text-3xl font-light tracking-wide whitespace-nowrap\"\n                  />\n                </div>\n              </div>\n\n              {/* Language selector and button */}\n              <div\n                className={cn(\n                  \"flex w-full flex-col gap-4 transition-opacity duration-500\",\n                  !scribe.isConnected && scribe.status !== \"connecting\"\n                    ? \"opacity-100\"\n                    : \"pointer-events-none opacity-0\"\n                )}\n              >\n                <div className=\"flex flex-col items-center gap-6\">\n                  <div className=\"flex flex-col items-center gap-2 text-center\">\n                    <h1 className=\"text-2xl font-semibold tracking-tight\">\n                      Realtime Speech to Text\n                    </h1>\n                    <p className=\"text-muted-foreground text-sm\">\n                      Transcribe your voice in real-time with high accuracy\n                    </p>\n                  </div>\n\n                  <div className=\"w-full space-y-2\">\n                    <label className=\"text-foreground/70 text-sm font-medium\">\n                      Language\n                    </label>\n                    <LanguageSelector\n                      value={selectedLanguage}\n                      onValueChange={setSelectedLanguage}\n                      disabled={\n                        scribe.isConnected || scribe.status === \"connecting\"\n                      }\n                    />\n                  </div>\n\n                  <Button\n                    onClick={handleToggleRecording}\n                    disabled={isOperating}\n                    size=\"lg\"\n                    className=\"bg-foreground/95 hover:bg-foreground/90 w-full justify-center gap-3\"\n                  >\n                    <span>Start Transcribing</span>\n                    <kbd className=\"border-background/20 bg-background/10 hidden h-5 items-center gap-1 rounded border px-1.5 font-mono text-xs sm:inline-flex\">\n                      {isMac ? \"⌘K\" : \"Ctrl+K\"}\n                    </kbd>\n                  </Button>\n\n                  <Badge variant=\"outline\" asChild>\n                    <Link\n                      href=\"https://elevenlabs.io/speech-to-text\"\n                      target=\"_blank\"\n                      rel=\"noopener noreferrer\"\n                      className=\"text-foreground/60 hover:text-foreground/80 transition-colors\"\n                    >\n                      Powered by ElevenLabs Speech to Text\n                    </Link>\n                  </Badge>\n                </div>\n              </div>\n            </div>\n          )}\n        </div>\n\n        {/* Bottom controls - stop button */}\n        <BottomControls\n          isConnected={scribe.isConnected}\n          hasError={Boolean(recording.error)}\n          isMac={isMac}\n          onStop={handleToggleRecording}\n        />\n      </div>\n    </div>\n  )\n}\n\nconst TranscriberTranscript = React.memo(\n  ({\n    transcript,\n    error,\n    isPartial,\n    isConnected,\n  }: {\n    transcript: string\n    error: string\n    isPartial?: boolean\n    isConnected: boolean\n  }) => {\n    const characters = useMemo(() => transcript.split(\"\"), [transcript])\n    const previousNumChars = useDebounce(\n      usePrevious(characters.length) || 0,\n      100\n    )\n    const scrollRef = useRef<HTMLDivElement>(null)\n    const scrollTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n\n    // Auto-scroll to bottom when connected and text is updating\n    // Throttled to avoid excessive scroll updates\n    useEffect(() => {\n      if (isConnected && scrollRef.current) {\n        if (scrollTimeoutRef.current) {\n          clearTimeout(scrollTimeoutRef.current)\n        }\n        scrollTimeoutRef.current = setTimeout(() => {\n          if (scrollRef.current) {\n            scrollRef.current.scrollTop = scrollRef.current.scrollHeight\n          }\n        }, 50) // Throttle scroll updates to 50ms\n      }\n      return () => {\n        if (scrollTimeoutRef.current) {\n          clearTimeout(scrollTimeoutRef.current)\n        }\n      }\n    }, [transcript, isConnected])\n\n    return (\n      <div className=\"absolute inset-0 flex flex-col\">\n        <div ref={scrollRef} className=\"flex-1 overflow-auto\">\n          <div\n            className={cn(\n              \"min-h-[50%] w-full px-12 py-8\",\n              isConnected && \"absolute bottom-16\"\n            )}\n          >\n            <div\n              className={cn(\n                \"text-foreground/90 w-full text-xl leading-relaxed font-light\",\n                error && \"text-red-500\",\n                isPartial && !error && \"text-foreground/60\"\n              )}\n            >\n              {characters.map((char, index) => {\n                // Only animate new characters (those after previousNumChars)\n                const delay =\n                  index >= previousNumChars\n                    ? (index - previousNumChars + 1) * 0.012\n                    : 0\n                return (\n                  <TranscriptCharacter key={index} char={char} delay={delay} />\n                )\n              })}\n            </div>\n          </div>\n        </div>\n        {transcript && !error && !isPartial && (\n          <Button\n            variant=\"ghost\"\n            size=\"icon\"\n            className=\"absolute top-4 right-4 h-8 w-8 opacity-0 transition-opacity hover:opacity-60\"\n            onClick={() => {\n              navigator.clipboard.writeText(transcript)\n            }}\n            aria-label=\"Copy transcript\"\n          >\n            <Copy className=\"h-4 w-4\" />\n          </Button>\n        )}\n      </div>\n    )\n  }\n)\nTranscriberTranscript.displayName = \"TranscriberTranscript\"\n",
      "type": "registry:page",
      "target": "app/realtime-transcriber-01/page.tsx"
    },
    {
      "path": "blocks/realtime-transcriber-01/actions/get-scribe-token.ts",
      "content": "\"use server\"\n\nexport interface ScribeTokenResult {\n  token?: string\n  error?: string\n}\n\nexport async function getScribeToken(): Promise<ScribeTokenResult> {\n  try {\n    const apiKey = process.env.ELEVENLABS_API_KEY\n\n    if (!apiKey) {\n      return { error: \"Service not configured\" }\n    }\n\n    const response = await fetch(\n      \"https://api.elevenlabs.io/v1/single-use-token/realtime_scribe\",\n      {\n        method: \"POST\",\n        headers: {\n          \"xi-api-key\": apiKey,\n        },\n      }\n    )\n\n    if (!response.ok) {\n      const errorText = await response.text()\n      console.error(\"Failed to get Scribe token:\", errorText)\n      return { error: \"Failed to get transcription token\" }\n    }\n\n    const data = await response.json()\n\n    if (!data.token) {\n      return { error: \"Invalid token response\" }\n    }\n\n    return { token: data.token }\n  } catch (error) {\n    console.error(\"Error getting Scribe token:\", error)\n    return {\n      error: error instanceof Error ? error.message : \"Failed to get token\",\n    }\n  }\n}\n",
      "type": "registry:file",
      "target": "app/realtime-transcriber-01/actions/get-scribe-token.ts"
    },
    {
      "path": "blocks/realtime-transcriber-01/components/language-selector.tsx",
      "content": "\"use client\"\n\nimport { useState } from \"react\"\nimport { ChevronDown, Globe } from \"lucide-react\"\n\nimport { Button } from \"@/components/ui/button\"\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from \"@/components/ui/command\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\"\n\ninterface LanguageOption {\n  code: string\n  name: string\n}\n\nconst LANGUAGE_OPTIONS: LanguageOption[] = [\n  { code: \"af\", name: \"Afrikaans\" },\n  { code: \"ar\", name: \"Arabic\" },\n  { code: \"hy\", name: \"Armenian\" },\n  { code: \"az\", name: \"Azerbaijani\" },\n  { code: \"be\", name: \"Belarusian\" },\n  { code: \"bn\", name: \"Bengali\" },\n  { code: \"bs\", name: \"Bosnian\" },\n  { code: \"bg\", name: \"Bulgarian\" },\n  { code: \"ca\", name: \"Catalan\" },\n  { code: \"zh\", name: \"Chinese\" },\n  { code: \"hr\", name: \"Croatian\" },\n  { code: \"cs\", name: \"Czech\" },\n  { code: \"da\", name: \"Danish\" },\n  { code: \"nl\", name: \"Dutch\" },\n  { code: \"en\", name: \"English\" },\n  { code: \"et\", name: \"Estonian\" },\n  { code: \"fi\", name: \"Finnish\" },\n  { code: \"fr\", name: \"French\" },\n  { code: \"gl\", name: \"Galician\" },\n  { code: \"ka\", name: \"Georgian\" },\n  { code: \"de\", name: \"German\" },\n  { code: \"el\", name: \"Greek\" },\n  { code: \"gu\", name: \"Gujarati\" },\n  { code: \"he\", name: \"Hebrew\" },\n  { code: \"hi\", name: \"Hindi\" },\n  { code: \"hu\", name: \"Hungarian\" },\n  { code: \"is\", name: \"Icelandic\" },\n  { code: \"id\", name: \"Indonesian\" },\n  { code: \"it\", name: \"Italian\" },\n  { code: \"ja\", name: \"Japanese\" },\n  { code: \"kn\", name: \"Kannada\" },\n  { code: \"kk\", name: \"Kazakh\" },\n  { code: \"ko\", name: \"Korean\" },\n  { code: \"lv\", name: \"Latvian\" },\n  { code: \"lt\", name: \"Lithuanian\" },\n  { code: \"mk\", name: \"Macedonian\" },\n  { code: \"ms\", name: \"Malay\" },\n  { code: \"ml\", name: \"Malayalam\" },\n  { code: \"mr\", name: \"Marathi\" },\n  { code: \"ne\", name: \"Nepali\" },\n  { code: \"no\", name: \"Norwegian\" },\n  { code: \"fa\", name: \"Persian\" },\n  { code: \"pl\", name: \"Polish\" },\n  { code: \"pt\", name: \"Portuguese\" },\n  { code: \"ro\", name: \"Romanian\" },\n  { code: \"ru\", name: \"Russian\" },\n  { code: \"sr\", name: \"Serbian\" },\n  { code: \"sk\", name: \"Slovak\" },\n  { code: \"sl\", name: \"Slovenian\" },\n  { code: \"es\", name: \"Spanish\" },\n  { code: \"sw\", name: \"Swahili\" },\n  { code: \"sv\", name: \"Swedish\" },\n  { code: \"ta\", name: \"Tamil\" },\n  { code: \"te\", name: \"Telugu\" },\n  { code: \"th\", name: \"Thai\" },\n  { code: \"tr\", name: \"Turkish\" },\n  { code: \"uk\", name: \"Ukrainian\" },\n  { code: \"ur\", name: \"Urdu\" },\n  { code: \"vi\", name: \"Vietnamese\" },\n]\n\ninterface LanguageSelectorProps {\n  value: string | null\n  onValueChange: (code: string | null) => void\n  disabled?: boolean\n}\n\nexport function LanguageSelector({\n  value,\n  onValueChange,\n  disabled = false,\n}: LanguageSelectorProps) {\n  const [open, setOpen] = useState(false)\n\n  const selectedName = value\n    ? LANGUAGE_OPTIONS.find((l) => l.code === value)?.name || value\n    : \"Auto-detect\"\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button\n          variant=\"outline\"\n          role=\"combobox\"\n          aria-expanded={open}\n          className=\"w-full justify-between\"\n          disabled={disabled}\n        >\n          <span className=\"flex items-center gap-2\">\n            <Globe className=\"h-4 w-4\" />\n            {selectedName}\n          </span>\n          <ChevronDown className=\"ml-2 h-4 w-4 shrink-0 opacity-50\" />\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent className=\"w-[300px] p-0\" align=\"start\">\n        <Command>\n          <CommandInput placeholder=\"Search languages...\" />\n          <CommandList>\n            <CommandEmpty>No language found.</CommandEmpty>\n            <CommandGroup>\n              <CommandItem\n                value=\"auto-detect\"\n                onSelect={() => {\n                  onValueChange(null)\n                  setOpen(false)\n                }}\n              >\n                <Globe className=\"mr-2 h-4 w-4\" />\n                Auto-detect\n              </CommandItem>\n              {LANGUAGE_OPTIONS.map((language) => (\n                <CommandItem\n                  key={language.code}\n                  value={`${language.name} ${language.code}`}\n                  onSelect={() => {\n                    onValueChange(language.code)\n                    setOpen(false)\n                  }}\n                >\n                  {language.name} ({language.code})\n                </CommandItem>\n              ))}\n            </CommandGroup>\n          </CommandList>\n        </Command>\n      </PopoverContent>\n    </Popover>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/language-selector.tsx"
    }
  ],
  "meta": {
    "iframeHeight": "800px",
    "container": "w-full bg-surface min-h-svh flex px-4 py-12 items-center md:py-20 justify-center min-w-0",
    "mobile": "component"
  },
  "categories": [
    "audio-beta"
  ]
}